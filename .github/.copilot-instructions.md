# GitHub Copilot Instructions: Mastra (Gemini 2.0 Flash) + LangSmith + Prisma + Lucia + tRPC + Server Actions + MUI v7 in Next.js (`apps/web`) turborepo - v1.7

## ⭐ Copilot Guidance: Your Role & Core Directives (v17 - Max Detail) ⭐

* **Your Role:** Senior TypeScript Engineer building AI apps with Next.js 15, Mastra, Gemini 2.0 Flash, LangSmith, Prisma, Lucia, tRPC + Manual Server Actions, MUI Core v7 in a Turborepo. Focus on precision, best practices, security, observability, code reuse (services), and generating production-ready patterns guided by detailed inline directives (`// COPILOT:...`).
* **Primary Goal:** Integrate Mastra AI agents (using `gemini-2.0-flash`) into `apps/web`. Define core logic in reusable services. Expose via secure/validated tRPC procedures AND Manual Server Actions. Ensure LangSmith tracing. Implement type-safe MUI Core v7 frontend components (including streaming). Leverage existing Prisma DB.
* **Framework Choice:** **Mastra AI** exclusively. No LangChain.
* **Backend Strategy:** **Hybrid (tRPC + Server Actions)** calling shared **service functions** with explicit **Dependency Injection**. Use Server Actions for forms/simple mutations; use tRPC for queries/complex client state integration.
* **Database Integration:** **Mandatory:** Use **Prisma Client** from `@your-org/database`. Model AI data in `schema.prisma`. No separate DB.
* **Authentication:** **Mandatory:** Use **Lucia Auth** (`@your-org/auth`) via `validateRequest` (Server Actions) or tRPC context/middleware.
* **UI Library:** **Mandatory:** Use **MUI Core v7** components.
* **Core Directives:** (Strict Adherence Required - Type Safety, Gemini Target, LangSmith, Mastra Idioms, Backend Implementation, Error Handling, Security, Streaming, State, Caching, etc. - See detailed sections).

## Project Context & Key Technologies (Verified Stack)

* **Monorepo:** Turborepo
* **Package Manager:** pnpm
* **Target App:** `apps/web` (Next.js 15, pages Router, React 19.1, TS 5.8.3+)
* **Database:** `@your-org/database` (**Prisma**) - **VERIFY SCOPE/NAME**
* **Authentication:** `@your-org/auth` (**Lucia Auth** w/ Prisma adapter) - **VERIFY SCOPE/NAME**
* **API Layer:** **Hybrid:** tRPC (`@your-org/api` - **VERIFY SCOPE/NAME**) + Manual Server Actions (`apps/web/app/_actions/`).
* **Client State:** TanStack Query (`@tanstack/react-query`).
* **Validation:** `@your-org/validators` (Zod) - **VERIFY SCOPE/NAME**
* **UI Library:** **MUI Core v7** (`@mui/material`, etc.)
* **AI Framework:** Mastra (`@mastra/core`, `mastra-cli`) - **To be added**
* **LLM Provider:** Google Gemini API (via Mastra/Vercel AI SDK) - Target `gemini-2.0-flash`.
* **Observability:** LangSmith - **To be added** (via Env Vars).
* **Key Files/Dirs:** (See previous versions, includes `instrumentation.ts`, `services/`, `_actions/`, `api/router/`, `mastra/`, etc.)

## Initial Mastra Setup (`apps/web`)

* **Goal:** Install and initialize Mastra in `apps/web`.
* **Directory:** Run commands in `apps/web`.
* **Installation:**

    ```bash
    # COPILOT: Install Mastra core runtime
    pnpm add @mastra/core
    # COPILOT: Install Mastra CLI for development
    pnpm add -D mastra-cli
    ```

* **Initialization:**

    ```bash
    # COPILOT: Run mastra init using npx
    npx mastra@latest init
    ```

  * **Action:** Review generated files (`mastra.config.ts`?, `src/lib/mastra/`?). Adapt structure. **COPILOT: Ensure config uses env vars for secrets.**
* **Turborepo Integration:**
  * **Scripts:** **COPILOT: Add `mastra:dev` script to `apps/web/package.json`.**
  * **`turbo.json`:** Configure `dev` pipeline if needed.

## Turborepo Environment Variable Management & Dependencies

* **(Env Vars):** Declare build-affecting vars in `turbo.json` `build.env`. Runtime vars must be present in deployment. **COPILOT: Remind user about declaring vars like `DEFAULT_GEMINI_MODEL`.**
* **Task Dependencies:** Ensure `turbo.json` reflects accurate dependencies (`apps/web` -> `@your-org/api`, `@your-org/database`, etc.). `apps/web#build` MUST depend on `packages/database#build` (for `prisma generate`). **COPILOT: Ensure `packages/database#build` runs `prisma generate`.**

## Detailed Implementation Guidance & Examples (v17 - Enhanced Details)

1. **Mastra Configuration (`apps/web/instrumentation.ts`):** (Example structure similar to v15 - **COPILOT: Verify Mastra API for provider/telemetry config.** Prioritize env vars.)

2. **Define Core Types & Schemas (`@your-org/validators`, `apps/web/src/lib/mastra/types.ts`):**
    * **Goal:** Define Zod schemas, types, standardized responses, `ActionErrorCode` enum, `ServiceError` class.
    * **Copilot Task:** Generate Zod schemas in `@your-org/validators`. Generate types, enum, and class in `mastra/types.ts`. Import Prisma types. Define `AppServerActionResponse`.
    * **Example Snippets:** (Structure similar to v13, ensure `ServiceError` class is well-defined).

```typescript
        // apps/web/src/lib/mastra/types.ts
        // ... imports ...
        // COPILOT: Expand ActionErrorCode with more specific cases
        export enum ActionErrorCode {
          // General
          UnknownError = "UNKNOWN_ERROR", ServiceUnavailable = "SERVICE_UNAVAILABLE",
          // Auth
          Unauthorized = "AUTH_UNAUTHORIZED", Forbidden = "AUTH_FORBIDDEN",
          // Validation
          ValidationError = "VALIDATION_ERROR", // Input validation failed
          // Database
          DatabaseError = "DB_ERROR", NotFound = "DB_NOT_FOUND", Conflict = "DB_CONFLICT", PrismaUnknown = "DB_PRISMA_UNKNOWN", PrismaUniqueConstraint = "DB_PRISMA_UNIQUE", // Example Prisma code mapping
          // Agent/LLM
          AgentExecutionFailed = "AGENT_EXECUTION_FAILED", AgentToolFailed = "AGENT_TOOL_FAILED", RateLimitExceeded = "LLM_RATE_LIMIT", LlmError = "LLM_ERROR", // Generic LLM failure
          // Tools
          ToolNetworkError = "TOOL_NETWORK_ERROR", ToolInputError = "TOOL_INPUT_ERROR",
        }

        // COPILOT: Define ServiceError class for consistent error handling from services
        export class ServiceError extends Error {
          readonly code: ActionErrorCode;
          readonly cause?: unknown; // Optional underlying cause
          constructor(message: string, code: ActionErrorCode = ActionErrorCode.UnknownError, cause?: unknown) {
            super(message);
            this.code = code;
            this.cause = cause;
            this.name = 'ServiceError';
            Object.setPrototypeOf(this, ServiceError.prototype);
          }
        }
        // ... AppServerActionResponse type definition ...
```

3. **Define Mastra Agent (`apps/web/src/lib/mastra/agents/`):**

(Structure similar to previous versions - **COPILOT: Add detailed comments guiding prompt engineering for tool reliability.** Verify Mastra API.)

4. **Define Mastra Tool using Database (`apps/web/src/lib/mastra/tools/`):**

* **Goal:** Create tool using Prisma, potentially accepting `db` dependency *via the service layer*.
* **Copilot Task:** Generate Tool definition using `createTool`. Import `PrismaClient` type if needed for internal logic. The tool's `execute` function receives standard context (`threadId`, `resourceId`, input `context`). If direct DB access is needed, design the tool's implementation to accept `db` from the calling service function. Handle Prisma errors within the tool's logic, throw `ServiceError` with specific codes.
* **Example Snippet:** (Structure similar to v14 - **COPILOT: Ensure standard `execute` context is used. If `db` is required, the service function should pass it to the tool's implementation logic, not via `agent.generate/stream` context.** Verify Mastra `createTool` API.)

5. **Implement Shared AI Service Function (`apps/web/src/lib/services/aiService.ts`):**

    * **Goal:** Encapsulate Mastra + Prisma logic. Accept dependencies. Throw `ServiceError`.
    * **Copilot Task:** Create service functions. Accept `db: PrismaClient`, `agent` instance. Implement DB logic (with **explicit ownership checks**). Call `agent.run()` (passing `db` to tools). Handle errors by throwing `ServiceError` with specific codes (map Prisma codes).
    * **Example Snippet (Conceptual Chat Service with DI):**

```typescript
        // apps/web/src/lib/services/aiService.ts
        // ... imports including ServiceError, ActionErrorCode, PrismaClient, chatAgent instance, db instance (for type only)...
        // COPILOT: Import Prisma namespace for error types from '@your-org/database'
        import { Prisma } from '@your-org/database';
        // COPILOT: Import agent execution types if needed
        import { type GenerateTextResult, type StreamTextResult } from '@mastra/core'; // Or '@ai-sdk/core' depending on source

        // ... ServiceContext, ChatServiceResult interfaces ...

        // COPILOT: Service function accepts db and agent instance as arguments (Dependency Injection)
        export async function handleChatMessage(
             /* ... input, ctx, db, agent ... */
             // COPILOT: Add parameters like threadId, resourceId if needed for agent memory
             threadId: string | undefined,
             resourceId: string | undefined,
          ): Promise<ChatServiceResult> {
            // ... userId extraction from ctx ...
            const userMessage = input.message; // Example input structure

            try {
                // 1. DB Reads + Ownership Check
                // COPILOT: MANDATORY - Use 'userId' (as resourceId) for ownership check with Prisma 'where' clause if applicable
                // const conversation = await db.conversation.findFirst({ where: { id: threadId, userId: resourceId } });
                // if (!conversation && threadId) throw new ServiceError("...", ActionErrorCode.Forbidden);
                // ... handle conversation/history logic using injected 'db' ...
                // COPILOT: Note - Mastra's Memory system handles history injection if configured and threadId/resourceId are passed.

                // 2. Call Agent (Use generate for single response, stream for streaming)
                // COPILOT: Use agent.generate() or agent.stream(). Pass threadId/resourceId for memory.
                // COPILOT: Passing arbitrary dependencies like 'db' to tools via agent context is NOT confirmed in docs.
                // COPILOT: If a tool needs 'db', the service should invoke the tool's logic function directly and pass 'db'.
                const agentResponse: GenerateTextResult = await agent.generate(
                   userMessage,
                   { threadId, resourceId } // Pass IDs for memory context
                   // COPILOT: Add other options like `tools`, `toolChoice` if needed, but NOT { dependencies: { db } }
                );
                // OR: const agentStream: StreamTextResult = await agent.stream(userMessage, { threadId, resourceId });

                // 3. Process Agent Response/Stream
                // ... handle agentResponse.text or process agentStream ...
                // COPILOT: Defensive check for tool usage/output if applicable from agentResponse.toolCalls / agentResponse.toolResults

                // 4. DB Writes using injected 'db'
                // ... e.g., save user message and agent response to your application's tables ...
                // COPILOT: Note - Mastra's Memory system handles saving to *its* store automatically. Save application data separately.

                // 5. Return Success Data
                return { text: agentResponse.text /* ... other data ... */ };

            } catch (error: any) {
                // COPILOT: Catch specific errors, map to ServiceError with specific ActionErrorCode
                console.error("Error in handleChatMessage service:", error);
                if (error instanceof ServiceError) throw error; // Re-throw if already handled
                if (error instanceof Prisma.PrismaClientKnownRequestError) {
                    // COPILOT: Map relevant Prisma error codes to ActionErrorCodes
                    let code = ActionErrorCode.DatabaseError;
                    if (error.code === 'P2002') code = ActionErrorCode.Conflict; // Unique constraint
                    if (error.code === 'P2025') code = ActionErrorCode.NotFound; // Record not found for update/delete
                    throw new ServiceError(`Database error: ${error.message}`, code, error);
                }
                // COPILOT: Add checks for specific Mastra/Gemini API errors if possible (e.g., from response metadata/error types), map to codes like RateLimitExceeded, LlmError
                // Fallback
                throw new ServiceError(error.message || "Unknown service error", ActionErrorCode.UnknownError, error);
            }
        }
```

6. **tRPC Procedure Implementation (`packages/api/src/router/ai.ts`):**

* **Goal:** Expose AI service via tRPC, injecting `db` from context.
* **Copilot Task:** Define procedure. Use Zod schema. Use protected procedure (Lucia via context). Inject `db`. Call service (pass `db`, agent instance, `threadId`/`resourceId` from input/context). Catch `ServiceError` and map code to `TRPCError` code.
* **Example Snippet:** (Structure similar to v14 - **COPILOT: Ensure `db` is correctly accessed from `ctx`. Ensure service call uses `agent.generate/stream` pattern. Implement detailed `ServiceError` code mapping to `TRPCError` codes.**)

7. **Server Action Implementation (`apps/web/app/_actions/`):**

* **Goal:** Expose AI service via Manual Server Action, injecting `db`.
* **Copilot Task:** Generate Manual Server Action. Include Lucia `validateRequest`. Use Zod schema. Import `db`, agent instance. Call service (pass `db`, agent instance, `threadId`/`resourceId` from input/context). Catch `ServiceError`, map code to standard error object. Invalidate cache.
* **Example Snippet:** (Structure similar to v14 - **COPILOT: Ensure `db` and `agent` are imported and passed. Ensure service call uses `agent.generate/stream` pattern. Implement detailed `ServiceError` code mapping to `ActionErrorCode` in the returned error object.**)

8. **Frontend Component (`app/components/` using MUI v7 + EITHER tRPC Hook OR Manual Action):**

    * **Goal:** Call backend, handle states robustly, use MUI v7. Invalidate caches.
    * **Copilot Task:** Provide **two distinct component examples**: one using tRPC `useMutation`, one calling the Manual Server Action. Both should:
        * Use MUI v7 components (`TextField`, `Button`, `Alert`, `CircularProgress`, etc.).
        * Handle pending state correctly.
        * Handle validation errors (displaying field-specific errors from Zod via tRPC/Action response).
        * Handle server errors, mapping `ActionErrorCode` (from Server Action response or mapped TRPCError) to user-friendly messages in MUI `Alert`.
        * Implement optimistic error clearing on input change.
        * Call `queryClient.invalidateQueries` on success if data affects tRPC queries.
        * Include detailed `// COPILOT:` comments for each part.
    * **Example Snippet (Manual Action Focus - Enhanced):**

```typescript

        // apps/web/app/components/ChatInterfaceManualAction.tsx
        'use client';
        // ... imports: React hooks, action, types (incl ActionErrorCode), MUI components, queryClient ...

        // COPILOT: Define a helper function or map for user-friendly error messages based on ActionErrorCode
        const mapErrorCodeToUserMessage = (code?: ActionErrorCode): string => {
          switch (code) {
            case ActionErrorCode.Unauthorized: return "Please log in again.";
            case ActionErrorCode.Forbidden: return "You don't have permission for this action.";
            case ActionErrorCode.ValidationError: return "Please check the highlighted fields.";
            case ActionErrorCode.RateLimitExceeded: return "Too many requests, please try again later.";
            case ActionErrorCode.NotFound: return "Resource not found.";
            // Add more mappings
            default: return "An unexpected error occurred. Please try again.";
          }
        };

        export function ChatInterfaceManualAction({ /* ... props ... */ }: ChatInterfaceProps) {
          // ... state: isPending, error (string | null), fieldErrors (Record<string, string[]> | null), messages, conversationId ...
          // const queryClient = useQueryClient();

          const handleSubmit = async (formData: FormData) => {
             // ... set pending true, clear errors ...
             const response = await processUserChatMessageAction(formData); // Manual action call
             // ... set pending false ...

             if (response.status === 'success') {
                // ... handle success: reset form, update messages state ...
                // COPILOT: Invalidate relevant TanStack Query cache after successful mutation
                // queryClient.invalidateQueries({ queryKey: ['conversations', response.data.conversationId, 'messages'] });
             } else if (response.status === 'validationError') {
                // COPILOT: Set both general validation message and specific field errors
                setFieldErrors(response.error.fieldErrors);
                setError(mapErrorCodeToUserMessage(ActionErrorCode.ValidationError));
             } else { // status === 'error'
                // COPILOT: Map the specific error code from the response to a user-friendly message
                setError(mapErrorCodeToUserMessage(response.error.code));
             }
          };
          // ... handleInputChange to clear errors ...

          return (
            <Box /* ... MUI layout ... */ >
              {/* ... MUI List for messages ... */}
              <form ref={formRef} action={handleSubmit}>
                <Box /* ... MUI layout for input + button ... */ >
                  {/* COPILOT: Use MUI TextField. Bind error state using 'error' prop. Display helperText from 'fieldErrors'. */}
                  <TextField name="message" error={!!fieldErrors?.message} helperText={fieldErrors?.message?.join(', ')} /* ... other props ... */ />
                  {/* COPILOT: Use MUI Button. Bind 'disabled' to isPending. Show CircularProgress when pending. */}
                  <Button type="submit" disabled={isPending} /* ... */ >{isPending ? <CircularProgress size={24}/> : 'Send'}</Button>
                </Box>
              </form>
              {/* COPILOT: Display general errors using MUI Alert based on 'error' state */}
              {error && <Alert severity={fieldErrors ? "warning" : "error"} sx={{ mt: 2 }}>{error}</Alert>}
              {/* ... Display success data ... */}
            </Box>
          );
        }

```

**(Include a similar detailed example for the tRPC `useMutation` pattern)**

9. **Streaming Pattern (API Route Recommended):

  **Goal:** Implement streaming via API Route + Vercel AI SDK / Mastra `stream()`.
  **Copilot Task:** Generate complete API Route handler (`app/api/ai/stream/route.ts`) with auth, context fetching (Prisma), call to agent's `stream()` method (passing `threadId`/`resourceId`), error handling. Generate frontend component using `useChat` hook connected to this route, rendering streamed MUI output. Use `maskStreamTags` on the frontend if using Mastra's Working Memory feature.
  **Example Snippets:** (Provide more complete, runnable conceptual examples for both backend route calling `agent.stream()` and frontend `useChat` component, including necessary imports and setup like `maskStreamTags`).

10. **Multimodal Input Handling:**

    * **Goal:** Guide passing image/audio data.
    * **Copilot Task:** Provide conceptual code snippet for structuring `CoreMessage[]` with text and image (base64) parts for Vercel AI SDK. Add `// COPILOT: Verify exact structure required by Mastra/AI SDK for multimodal input.`
    * **Example Snippet:**

        ```typescript
        // Conceptual input for multimodal Gemini call via AI SDK
        const messages: CoreMessage[] = [
          {
            role: 'user',
            content: [
              { type: 'text', text: 'Describe this image:' },
              // COPILOT: Ensure image data is correctly formatted (e.g., base64 string) and MIME type is provided if needed by the SDK/model.
              { type: 'image', image: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUg...' /* base64 string or URL */ }
            ]
          }
        ];
        // COPILOT: Pass this 'messages' array to the agent/streamText function. Verify Mastra/AI SDK API.
        ```

11. **Stateful Agents / Memory:** (Enhance service function example (`handleChatMessage`) with more explicit `// COPILOT:` comments detailing: configuring Mastra Memory (potentially using PostgreSQL adapter if Prisma uses PG), passing `threadId`/`resourceId` to `agent.generate/stream`, and separately saving application-specific data using the injected `db` client)..

12. **Rate Limiting & Retries:** ***Goal:** Add resilience to backend service calls.* **Copilot Task:** Show conceptual use of `async-retry` wrapping `agent.generate()` or `agent.stream()` in the service function. Add comments about configuring retry strategy and checking Gemini rate limit headers or specific error types from the agent response/error. *(Note: This backend retry is separate from the Mastra Client SDK's built-in retries for client-server HTTP calls).*

    * **Example Snippet (Inside Service Function `try` block):**

```typescript
    // ... (Mocking Prisma Client - unchanged) ... // ... (Mocking Lucia validateRequest - unchanged) ... // ** Mocking Mastra agent.generate/stream (in test file, assuming agent instance is imported) ** // COPILOT: Use vi.spyOn to mock a method on an imported instance //
    import { vi } from 'vitest'; //
 import { chatAgent } from '@/lib/mastra/agents/chatAgent'; // Import the actual agent instance // // // Mock generate //
    const mockAgentGenerate = vi.spyOn(chatAgent, 'generate').mockResolvedValue({ //
    text: "Mocked AI response", //
    Mock the expected success structure from generate // //
    toolCalls: [], toolResults: [], finishReason: 'stop', usage: {...}, warnings: [], rawResponse: {}, ... // }); //
     // Or mock a failure:
     .mockRejectedValue(new Error("Mock agent failure")); // // //
     Mock stream (if testing streaming logic) - more complex, might mock the async iterator //
     const mockAgentStream = vi.spyOn(chatAgent, 'stream').mockImplementation(async () => { // // Return an object matching StreamTextResult, potentially with a mock stream/iterator //
     return { //
     stream: (async function* () { //
     yield { type: 'text-delta', textDelta: 'Mocked ' }; //
     yield { type: 'text-delta', textDelta: 'stream response' }; // //
     yield { type: 'tool-call', toolCallId: '...', toolName: '...', args: '...' }; // //
     yield { type: 'tool-result', toolCallId: '...', toolName: '...', result: '...' }; //
     yield { type: 'finish', finishReason: 'stop', usage: { completionTokens: 3, promptTokens: 10, totalTokens: 13 } }; //
      })(), //
      // Include other parts of StreamTextResult like .text(), .toAIStream(), etc. if needed by the test //
       text: async () => Promise.resolve('Mocked stream response'), // // ... mock other methods/properties as required by the code under test // }; // }); \
```

13. **Debugging & Testing Strategy:**

    * **Goal:** Provide concrete mocking examples.
    * **Copilot Task:** Add specific code comment examples using `vi.mock` (Vitest) for Prisma Client, Lucia `validateRequest`, and `agent.run`.
    * **Example Snippets (Conceptual Mocks for Vitest):**

```typescript
        // ** Mocking Prisma Client (in test setup or test file) **
        // COPILOT: Use vi.mock for mocking the entire database package
        // import { vi } from 'vitest';
        // vi.mock('@your-org/database', async (importOriginal) => {
        //   const actual = await importOriginal<typeof import('@your-org/database')>();
        //   return {
        //     ...actual, // Keep other exports if needed
        //     db: { // Mock the 'db' export
        //       user: {
        //         findUnique: vi.fn().mockResolvedValue({ id: 'mock-user-id', email: 'test@example.com', name: 'Test User' }),
        //         // Add mocks for other models/methods used (findFirst, create, findMany, $transaction etc.)
        //       },
        //       conversation: { /* ... mock methods ... */ },
        //       message: { /* ... mock methods ... */ },
        //       // Mock $transaction if used
        //       $transaction: vi.fn().mockImplementation(async (prismaPromises) => {
        //          const results = [];
        //          for (const p of prismaPromises) { results.push(await p); } // Simulate sequential execution
        //          return results;
        //       }),
        //     }
        //   };
        // });

        // ** Mocking Lucia validateRequest (in test file) **
        // COPILOT: Use vi.mock for mocking the auth package
        // import { vi } from 'vitest';
        // vi.mock('@your-org/auth', () => ({
        //   validateRequest: vi.fn().mockResolvedValue({ user: { id: 'mock-user-id', role: 'USER' }, session: { id: 'mock-session-id', /* ... */} }), // Mock successful auth
        //   // Or mock failed auth: vi.fn().mockResolvedValue({ user: null, session: null })
        //   lucia: {} // Mock other exports if needed
        // }));

        // ** Mocking Mastra agent.run (in test file, assuming agent instance is imported) **
        // COPILOT: Use vi.spyOn to mock a method on an imported instance
        // import { vi } from 'vitest';
        // import { chatAgent } from '@/lib/mastra/agents/chatAgent'; // Import the actual agent instance
        // const mockAgentRun = vi.spyOn(chatAgent, 'run').mockResolvedValue({
        //    output: { responseText: "Mocked AI response" }, // Mock the expected success structure
        //    metadata: { modelUsed: 'mock-model', /* ... */ }
        // });
        // Or mock a failure: .mockRejectedValue(new Error("Mock agent failure"));

```

## Final Verification Checklist for Copilot (v17 - Max Detail)

* [ ] **Project Scope:** Placeholders used? Focus on `apps/web`?
* [ ] **Framework Choice:** Only **Mastra AI**?
* [ ] **Backend Strategy:** Hybrid understood? Services w/ DI? Correct usage pattern?
* [ ] **Database:** **Prisma Client** used correctly in services?
* [ ] **Authentication:** **Lucia Auth** used correctly in tRPC & Server Actions?
* [ ] **UI Library:** **MUI Core v7** components used correctly?
* [ ] **Gemini Version:** **`gemini-2.0-flash`** targeted? API Key? Safety settings?
* [ ] **Type Safety:** Explicit types? Zod validation? Prisma types? No `any`? `ServiceError`? Standardized responses w/ codes?
* [ ] **Mastra Usage:** APIs verified (using `generate`/`stream`)? Clear tool prompts? Defensive checks? **Tool DI pattern clarified (likely via service)?** `// COPILOT: Verify...` comments updated?
* [ ] **tRPC:** Procedures defined? Input validation? Auth? Calls service (w/ DI)? Maps `ServiceError` to `TRPCError`?
* [ ] **Manual Server Actions:** Correct structure? Auth check? Zod validation? Calls service (w/ DI)? Manual `try/catch`? Maps `ServiceError`? Cache invalidation?
* [ ] **Frontend:** MUI v7? Calls tRPC hook OR Server Action? Handles all states (incl. specific error codes)? Invalidate**s** TanStack Query cache? **Separate examples provided?**
* [ ] **Observability:** LangSmith via env vars assumed? Errors logged? Sensitive data excluded?
* [ ] **Turborepo Env Vars & Deps:** Build vars in `turbo.json` `env`? Runtime vars available? Task dependencies correct?
* [ ] **Security:** Inputs validated? PII logging avoided? Auth/ownership checks (Prisma via service)?\
* [ ] **Stateful Agents:** Memory via Mastra Memory system (using `threadId`/`resourceId`)? **Persistence options considered (e.g., PG adapter)?** Application data saved separately via `db`? Explicit comments in example?**
* [ ] **Streaming:** **API Route pattern** recommended? **Complete examples (backend/frontend)?*
* [ ] **Advanced Concepts:** Multimodality example structure? **Rate limit/retry pattern uses `generate`/`stream` and clarifies backend vs client SDK retries?**
* [ ] **DX:** Debugging tips? **Specific testing/mocking examples updated for `generate`/`stream`?** Inline `// COPILOT:` comments detailed and actionable?
